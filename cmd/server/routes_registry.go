package main

import (
	"fmt"
	"sort"
	"strings"

	"github.com/labstack/echo/v4"
)

// RouteInfo contains metadata about a registered route
type RouteInfo struct {
	Method      string
	Path        string
	Name        string
	Version     string
	Deprecated  bool
	Description string
}

// GetRouteRegistry returns a complete inventory of all registered routes
// This is useful for API documentation, testing, and migration planning
func GetRouteRegistry(e *echo.Echo) []RouteInfo {
	routes := []RouteInfo{}

	for _, route := range e.Routes() {
		// Skip HEAD methods (auto-generated by Echo)
		if route.Method == "HEAD" {
			continue
		}

		info := RouteInfo{
			Method:  route.Method,
			Path:    route.Path,
			Name:    route.Name,
			Version: determineVersion(route.Path),
		}

		routes = append(routes, info)
	}

	// Sort by path for easier reading
	sort.Slice(routes, func(i, j int) bool {
		if routes[i].Path == routes[j].Path {
			return routes[i].Method < routes[j].Method
		}
		return routes[i].Path < routes[j].Path
	})

	return routes
}

// determineVersion extracts API version from route path
func determineVersion(path string) string {
	if len(path) >= 8 && path[:8] == "/api/v1/" {
		return "v1"
	}
	if len(path) >= 15 && path[:15] == "/admin/api/v1/" {
		return "admin-v1"
	}
	return "unversioned"
}

// PrintRouteRegistry prints a formatted route inventory to stdout
// Useful for debugging and documentation
func PrintRouteRegistry(e *echo.Echo) {
	registry := GetRouteRegistry(e)

	fmt.Println("\n" + strings.Repeat("=", 80))
	fmt.Println("ROUTE REGISTRY - Complete API Inventory")
	fmt.Println(strings.Repeat("=", 80))

	// Group by version
	versionGroups := make(map[string][]RouteInfo)
	for _, route := range registry {
		versionGroups[route.Version] = append(versionGroups[route.Version], route)
	}

	// Print in order: v1, admin-v1, unversioned
	versions := []string{"v1", "admin-v1", "unversioned"}

	for _, version := range versions {
		routes := versionGroups[version]
		if len(routes) == 0 {
			continue
		}

		fmt.Printf("\n[%s] - %d routes\n", version, len(routes))
		fmt.Println(strings.Repeat("-", 80))

		for _, route := range routes {
			fmt.Printf("  %-7s %s\n", route.Method, route.Path)
		}
	}

	fmt.Println("\n" + strings.Repeat("=", 80))
	fmt.Printf("Total Routes: %d\n", len(registry))
	fmt.Println(strings.Repeat("=", 80) + "\n")
}

// RouteStats provides statistics about route versioning
type RouteStats struct {
	TotalRoutes       int
	V1Routes          int
	AdminV1Routes     int
	UnversionedRoutes int
}

// GetRouteStats calculates statistics about route versioning
func GetRouteStats(e *echo.Echo) RouteStats {
	registry := GetRouteRegistry(e)
	stats := RouteStats{
		TotalRoutes: len(registry),
	}

	for _, route := range registry {
		switch route.Version {
		case "v1":
			stats.V1Routes++
		case "admin-v1":
			stats.AdminV1Routes++
		case "unversioned":
			stats.UnversionedRoutes++
		}
	}

	return stats
}

// PrintRouteStats prints route statistics
func PrintRouteStats(e *echo.Echo) {
	stats := GetRouteStats(e)

	fmt.Println("\n" + strings.Repeat("=", 80))
	fmt.Println("ROUTE STATISTICS")
	fmt.Println(strings.Repeat("=", 80))
	fmt.Printf("Total Routes:         %d\n", stats.TotalRoutes)
	fmt.Printf("API v1 Routes:        %d\n", stats.V1Routes)
	fmt.Printf("Admin API v1 Routes:  %d\n", stats.AdminV1Routes)
	fmt.Printf("Unversioned Routes:   %d (UI pages)\n", stats.UnversionedRoutes)
	fmt.Println(strings.Repeat("=", 80) + "\n")
}
