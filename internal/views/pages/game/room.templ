package game

import (
	"fmt"
	"github.com/google/uuid"
	"github.com/hekigan/couples/internal/models"
	"github.com/hekigan/couples/internal/viewmodels"
	"github.com/hekigan/couples/internal/views/fragments/room"
	"github.com/hekigan/couples/internal/views/layouts"
)

// RoomPage renders the room lobby page with layout
templ RoomPage(data *viewmodels.TemplateData) {
	@layouts.Base(data, RoomContent(data))
}

// RoomContainer renders just the room container (for SSE swaps)
templ RoomContainer(data *viewmodels.TemplateData) {
	if roomData, ok := data.Data.(map[string]interface{}); ok {
		if roomModel, ok := roomData["room"].(*models.Room); ok {
			<div
				class="room-container"
				data-room-id={ roomModel.ID.String() }
				data-is-owner={ fmt.Sprintf("%t", data.IsOwner) }
				data-selected-categories={ getSelectedCategoriesJSON(roomModel.SelectedCategories) }
				sse-swap="step_transition"
				hx-swap="outerHTML"
			>
				<!-- Step Indicator - Always visible -->
				@room.StepIndicator(models.GetRoomStep(roomModel))
				<!-- Players Section - Show only the other player -->
				<div class="room-players" id="player-list" data-testid="player-list">
					<!-- Guest sees the Owner card -->
					if !data.IsOwner {
						<div class="player-card" data-player="owner" data-testid="owner-card">
							<h4 class="player-label">Room Owner</h4>
							<span class="player-name" data-testid="owner-name">
								if data.OwnerUsername != "" {
									{ data.OwnerUsername }
								} else {
									Unknown
								}
							</span>
						</div>
					}
					<!-- Owner sees the Guest card - Updated via SSE when request accepted -->
					if data.IsOwner {
						<div
							class={ templ.KV("player-card", true), templ.KV("empty", roomModel.GuestID == nil) }
							data-player="guest"
							id="guest-info"
							sse-swap="request_accepted"
							data-testid="guest-card"
						>
							<h4 class="player-label">Playing with</h4>
							if roomModel.GuestID != nil {
								<span class="player-name" id="guest-name" data-testid="guest-name">
									if data.GuestUsername != "" {
										{ data.GuestUsername }
										if roomModel.GuestReady {
											<span
												class="badge badge-success"
												data-testid="room-guest-badge-status"
												sse-swap="room_guest-status_update"
												hx-swap="outerHTML"
											>
												ready
											</span>
										} else {
											<span
												class="badge badge-waiting"
												data-testid="room-guest-badge-status"
												sse-swap="room_guest-status_update"
												hx-swap="outerHTML"
											>
												not ready
											</span>
										}
									} else {
										Unknown
									}
								</span>
							} else {
								<span class="player-name" id="guest-waiting" data-testid="guest-waiting">Waiting for guest...</span>
							}
						</div>
					}
				</div>
				<!-- Step 1: Invite (owner only, step 1) -->
				if models.GetRoomStep(roomModel) == 1 && data.IsOwner {
					@room.Step1Invite(data)
				}
				<!-- Step 2: Categories (both players, steps 2-3) -->
				if models.GetRoomStep(roomModel) >= 2 {
					@room.Step2Categories(data, models.GetRoomStep(roomModel))
				}
				<!-- Step 3: Start (owner only, step 3) -->
				if models.GetRoomStep(roomModel) == 3 {
					@room.Step3Start(data)
				}
				<!-- Owner Actions (Delete Room) - OWNER ONLY -->
				if data.IsOwner {
					<div class="room-actions" data-testid="room-actions">
						<form action={ templ.URL(fmt.Sprintf("/game/room/%s/delete", roomModel.ID.String())) } method="POST" onsubmit="return confirm('Delete this room?');">
							if data.CSRFToken != "" {
								<input type="hidden" name="csrf" value={ data.CSRFToken }/>
							}
							<button type="submit" class="contrast" data-testid="delete-room-button">Delete Room</button>
						</form>
					</div>
				}
				<!-- Game Started redirect - Hidden element that receives SSE redirect fragment -->
				<div id="game-start-redirect" sse-swap="game_started" style="display:none;"></div>
			</div>
		}
	}
}

// RoomContent wraps RoomContainer with SSE connection
templ RoomContent(data *viewmodels.TemplateData) {
	if roomData, ok := data.Data.(map[string]interface{}); ok {
		if roomModel, ok := roomData["room"].(*models.Room); ok {
			<!-- SSE wrapper - maintains connection across swaps -->
			<div
				id="room-sse-wrapper"
				hx-ext="sse"
				sse-connect={ fmt.Sprintf("/api/v1/stream/rooms/%s/events", roomModel.ID.String()) }
			>
				@RoomContainer(data)
			</div>
			@RoomScript()
		}
	}
}

// RoomScript contains the JavaScript for the room page
templ RoomScript() {
	<script>
		// ============================================================================
		// MINIMAL JAVASCRIPT - Only for non-SSE features
		// ============================================================================
		// All SSE event handling is now done by HTMX

		// Copy room ID to clipboard
		function copyRoomId() {
			const input = document.getElementById('room-id-input');
			input.select();
			document.execCommand('copy');

			const btn = event.target;
			const originalText = btn.textContent;
			btn.textContent = 'âœ… Copied!';
			btn.style.background = '#10b981';

			setTimeout(() => {
				btn.textContent = originalText;
				btn.style.background = '';
			}, 2000);
		}

		// Load page state on DOM ready
		document.addEventListener('DOMContentLoaded', async () => {
			const container = document.querySelector('.room-container');
			const roomId = container?.dataset.roomId || '';
			const isOwner = container?.dataset.isOwner === 'true';

			console.log('ðŸ” Room ID:', roomId, 'IsOwner:', isOwner);

			// Fetch fresh state from database to fix race conditions
			try {
				console.log('ðŸ“¡ Fetching fresh room state...');
				const response = await fetch(`/api/v1/stream/rooms/${roomId}/state`);
				if (response.ok) {
					const state = await response.json();
					console.log('ðŸ“Š Fresh state loaded:', state);

					// If game already started, redirect
					if (state.status === 'playing') {
						console.log('ðŸŽ® Game already started, redirecting...');
						window.location.href = `/game/play/${roomId}`;
						return;
					}
				}
			} catch (error) {
				console.error('âŒ Failed to load initial state:', error);
			}

			console.log('âœ… HTMX SSE connection established via hx-ext="sse"');
			console.log('âœ… Phase A: Friends & Categories loading via HTMX hx-get');

			// Listen for guest ready notification (owner only)
			if (isOwner) {
				document.body.addEventListener('sse:room_update', function(e) {
					try {
						const data = JSON.parse(e.detail.data);
						if (data.guest_ready === true) {
							Toast.show({
								type: 'success',
								title: 'Partner Ready!',
								message: 'Your partner is ready. You can now start the game!',
								duration: 0
							});
						}
					} catch (error) {
						console.error('Error parsing room_update:', error);
					}
				});
			}
		});

		// ============================================================================
		// HTMX now handles:
		// - Friends list loading via hx-get="/api/v1/friends/list-html"
		// - Categories loading via hx-get="/api/v1/rooms/{id}/categories"
		// - Category toggle via hx-post in template (optimistic UI)
		// - Friend invitation via hx-post in template (server-rendered state transitions)
		// ============================================================================

		// ============================================================================
		// HTMX now handles:
		// - Guest ready button via hx-post="/api/v1/rooms/{id}/guest-ready"
		// - Start game button via hx-post="/api/v1/rooms/{id}/start"
		// - Category validation via hx-on::before-request in templates
		// - Button state syncing via SSE (room_update event)
		// ============================================================================

		// ============================================================================
		// UI Utilities
		// ============================================================================
		function showNotification(message, type) {
			const notification = document.createElement('div');
			notification.className = `notification notification-${type}`;
			notification.textContent = message;
			notification.style.cssText = `
				position: fixed;
				top: 20px;
				right: 20px;
				padding: 1rem 1.5rem;
				background: ${type === 'success' ? '#10b981' : '#ef4444'};
				color: white;
				border-radius: 8px;
				box-shadow: 0 4px 6px rgba(0,0,0,0.1);
				z-index: 10000;
				animation: slideIn 0.3s ease-out;
			`;

			document.body.appendChild(notification);

			setTimeout(() => {
				notification.style.animation = 'slideOut 0.3s ease-out';
				setTimeout(() => notification.remove(), 300);
			}, 3000);
		}

		// ============================================================================
		// HTMX will handle all SSE events automatically:
		// - join_request â†’ appends to #join-requests
		// - request_accepted â†’ replaces #guest-info
		// - categories_updated â†’ updates #categories-section
		// - game_started â†’ updates #game-start-redirect (triggers redirect)
		// - room_update â†’ handled by backend HTML fragments
		// ============================================================================

		// ============================================================================
		// Fix categories disabled state after SSE swap
		// SSE broadcasts same HTML to all users, but disabled state depends on role
		// ============================================================================
		function fixCategoriesDisabledState() {
			const container = document.querySelector('.room-container');
			const isOwner = container?.dataset.isOwner === 'true';
			const categoriesFieldset = document.querySelector('#categories-grid fieldset[data-guest-ready]');
			
			if (!categoriesFieldset) return;
			
			const guestReady = categoriesFieldset.dataset.guestReady === 'true';
			const checkboxes = categoriesFieldset.querySelectorAll('input[type="checkbox"]');
			
			// Guest should have disabled categories when guest is ready
			// Owner should always be able to toggle categories
			const shouldBeDisabled = !isOwner && guestReady;
			
			checkboxes.forEach(checkbox => {
				if (shouldBeDisabled) {
					checkbox.disabled = true;
					checkbox.setAttribute('aria-disabled', 'true');
					checkbox.title = 'Categories locked - guest is ready';
				} else {
					checkbox.disabled = false;
					checkbox.removeAttribute('aria-disabled');
					checkbox.title = '';
				}
			});
		}

		// Listen for HTMX swap events on categories grid
		document.body.addEventListener('htmx:afterSwap', function(e) {
			if (e.detail.target && e.detail.target.id === 'categories-grid') {
				fixCategoriesDisabledState();
			}
		});

		console.log('âœ… HTMX SSE mode active');
	</script>
}

// Helper function to convert selected categories to JSON string
func getSelectedCategoriesJSON(categories []uuid.UUID) string {
	if len(categories) == 0 {
		return ""
	}
	result := ""
	for i, cat := range categories {
		if i > 0 {
			result += ","
		}
		result += fmt.Sprintf("\"%s\"", cat.String())
	}
	return result
}
