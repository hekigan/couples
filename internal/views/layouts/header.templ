package layouts

import (
	"fmt"
	"github.com/hekigan/couples/internal/models"
	"github.com/hekigan/couples/internal/viewmodels"
	"reflect"
	"time"
)

// formatNotificationCount formats the notification count as a string, showing 99+ for counts > 99
func formatNotificationCount(count int) string {
	if count > 99 {
		return "99+"
	}
	return fmt.Sprintf("%d", count)
}

// getNotificationIcon returns the icon class for a notification type
func getNotificationIcon(notifType string) string {
	icons := map[string]string{
		models.NotificationTypeRoomInvite:     "icon-join-room",
		models.NotificationTypeFriendRequest:  "icon-people_alt",
		models.NotificationTypeFriendAccepted: "icon-sentiment_very_satisfied",
		models.NotificationTypeGameStart:      "icon-sports_esports",
		models.NotificationTypeMessage:        "icon-comments",
	}
	if icon, ok := icons[notifType]; ok {
		return icon
	}
	return "icon-notifications"
}

// formatNotificationTime formats a timestamp into a relative time string
func formatNotificationTime(t time.Time) string {
	now := time.Now()
	diff := now.Sub(t)

	if diff < time.Minute {
		return "Just now"
	}
	if diff < time.Hour {
		mins := int(diff.Minutes())
		return fmt.Sprintf("%dm ago", mins)
	}
	if diff < 24*time.Hour {
		hours := int(diff.Hours())
		return fmt.Sprintf("%dh ago", hours)
	}
	if diff < 7*24*time.Hour {
		days := int(diff.Hours() / 24)
		return fmt.Sprintf("%dd ago", days)
	}
	return t.Format("Jan 2")
}

// AggregatedNotification represents notifications grouped by type
type AggregatedNotification struct {
	Type      string
	Count     int
	Icon      string
	Label     string
	HasUnread bool
	Link      string
}

// aggregateNotifications groups notifications by type
func aggregateNotifications(notifications []*models.Notification) []AggregatedNotification {
	typeMap := make(map[string]*AggregatedNotification)

	typeLabels := map[string]string{
		models.NotificationTypeRoomInvite:     "Room invitation",
		models.NotificationTypeFriendRequest:  "Friend request",
		models.NotificationTypeFriendAccepted: "Friend accepted",
		models.NotificationTypeGameStart:      "Game started",
		models.NotificationTypeMessage:        "Message",
	}

	typeLinks := map[string]string{
		models.NotificationTypeRoomInvite:     "/game/rooms",
		models.NotificationTypeFriendRequest:  "/friends",
		models.NotificationTypeFriendAccepted: "/friends",
		models.NotificationTypeGameStart:      "/game/rooms",
		models.NotificationTypeMessage:        "/",
	}

	for _, notif := range notifications {
		if agg, exists := typeMap[notif.Type]; exists {
			agg.Count++
			if !notif.Read {
				agg.HasUnread = true
			}
		} else {
			label := typeLabels[notif.Type]
			if label == "" {
				label = "Notification"
			}
			link := typeLinks[notif.Type]
			if link == "" {
				link = "/"
			}

			typeMap[notif.Type] = &AggregatedNotification{
				Type:      notif.Type,
				Count:     1,
				Icon:      getNotificationIcon(notif.Type),
				Label:     label,
				HasUnread: !notif.Read,
				Link:      link,
			}
		}
	}

	// Convert map to slice
	result := make([]AggregatedNotification, 0, len(typeMap))
	for _, agg := range typeMap {
		result = append(result, *agg)
	}

	return result
}

// pluralizeLabel adds (s) if count > 1
func pluralizeLabel(label string, count int) string {
	if count > 1 {
		return label + "(s)"
	}
	return label
}

// getUserIDForHeader extracts the user ID from the User interface using reflection
func getUserIDForHeader(user interface{}) string {
	if user == nil {
		return ""
	}

	v := reflect.ValueOf(user)

	// If it's a pointer, get the element it points to
	if v.Kind() == reflect.Ptr {
		if v.IsNil() {
			return ""
		}
		v = v.Elem()
	}

	// If it's a struct, try to get the ID field
	if v.Kind() == reflect.Struct {
		idField := v.FieldByName("ID")
		if !idField.IsValid() {
			return ""
		}

		// Handle string ID (SessionUser)
		if idField.Kind() == reflect.String {
			return idField.String()
		}

		// Handle uuid.UUID type (models.User) - UUID has a String() method
		if idField.Type().Name() == "UUID" {
			// Call the String() method on uuid.UUID
			stringMethod := idField.MethodByName("String")
			if stringMethod.IsValid() {
				result := stringMethod.Call(nil)
				if len(result) > 0 {
					return result[0].String()
				}
			}
		}
	}

	return ""
}

// Header renders the main header navigation
templ Header(data *viewmodels.TemplateData) {
	<header class="main-header">
		<div class="container">
			<div class="header-content">
				<a href="/" class="logo">
					<span class="logo-icon">ðŸ’•</span>
					<span class="logo-text">Couple Card Game</span>
				</a>
				<button class="hamburger-btn" onclick="MobileMenu.open()" aria-label="Open menu">
					<span class="hamburger-icon">â˜°</span>
				</button>
				<nav class="main-nav">
					if data.User != nil {
						<!-- Notification Bell -->
						<span
							role="button"
							class="notification-bell nav-link"
							id="notification-btn"
							if getUserIDForHeader(data.User) != "" {
								data-user-id={ getUserIDForHeader(data.User) }
							}
						>
							<i class="icon-email text-lg"></i>
							<span
								id="notification-badge"
								if data.NotificationCount > 0 {
									class="notification-badge visible"
								} else {
									class="notification-badge"
									hidden
								}
							>
								{ formatNotificationCount(data.NotificationCount) }
							</span>
							<div class="notification-dropdown" id="notification-dropdown">
								<div class="notification-header">
									<button onclick="markAllRead()" class="mark-read-btn">Mark all read</button>
								</div>
								<div class="notification-list" id="notification-list" data-loaded="true">
									if len(data.Notifications) == 0 {
										<div class="empty">No notifications</div>
									} else {
										for _, agg := range aggregateNotifications(data.Notifications) {
											<a
												href={ templ.URL(agg.Link) }
												class={ "notification-item", templ.KV("unread", agg.HasUnread) }
											>
												<div class="notification-icon">
													<i class={ agg.Icon }></i>
												</div>
												<div class="notification-content">
													<div class="notification-title">
														<span class="notification-count-badge">{ fmt.Sprintf("%d", agg.Count) }</span>
														{ pluralizeLabel(agg.Label, agg.Count) }
													</div>
												</div>
												if agg.HasUnread {
													<div class="unread-dot"></div>
												}
											</a>
										}
									}
								</div>
							</div>
						</span>
						if data.IsAdmin {
							<a href="/admin" role="button" class="nav-link">Admin Dashboard</a>
						}
						<a href="/friends" role="button" class="nav-link">Friends</a>
						<a href="/game/rooms" role="button" class="nav-link">Rooms</a>
						<a href="/profile" role="button" class="nav-link">Profile</a>
						<a href="#" role="button" hx-post="/auth/logout" hx-confirm="Are you sure you want to logout?" class="nav-link">Logout</a>
					} else {
						<a href="/login" role="button">Login</a>
						<a href="/signup" role="button">Signup</a>
					}
				</nav>
			</div>
		</div>
	</header>
}
